Su misi´on, en esta tarea, es modificar el cliente con threads de la tarea 1
para hacer que funcione usando UDP y corrigiendo los errores de transmisi´on. Usaremos el mismo servidor de eco UDP normal y solo modificaremos
el cliente.
Ahora los dos threads del cliente se sincronizar´an como si fueran un
emisor y un receptor en un protocolo cl´asico de ventana corredera. La idea
es que implementen el mejor protocolo posible: si hacen un Stop-and-Wait
y no se pierde nada tienen un 4.0, si hacen un Go-Back-N bueno tienen un
5.5, si hacen un Selective-Repeat bueno tienen un 7.0.
La estructura de la soluci´on se parece a la de la Tarea 1, pero ahora
los dos threads deben adem´as sincronizarse para control de flujo: en Stopand-Wait deben esperar la recepci´on de cada paquete, en Go-Back-N y en
Selective-Repeat deben detenerse si la ventana de env´ıo se llen´o. Deben
mantener una ventana de env´ıo en el thread emisor y una de recepci´on en
el thread receptor. La ´unica diferencia importante con un protocolo normal,
es que no usar´an ACKs, ya que pueden compartir memoria entre emisor y
receptor, por lo que el receptor le puede avisar al emisor qu´e paquetes ha
recibido e incluso los threads pueden mirar la ventana del otro (con mutex
y esas cosas eso s´ı). Ver diagrama.
1
thread emisor
thread receptor
ventana envío
ventana recepción
servidor eco
cliente
Sincronización
(equivalente a
ACKs)
0001
0002
0003
0004
0005
0006
0007
0008
1|2|3|4|5|6|7|8
1 Descripci´on 2
1 Descripci´on 3
Para poder implementar eso, se les pide usar n´umeros de secuencia en
los paquetes, con 2 bytes binarios que representan el n´umero de secuencia
(0-65535), representaci´on big endian. Los n´umeros de secuencia cuentan los
paquetes enviados. Todos los paquetes que env´ıen deben venir con esos dos
caracteres, y as´ı los reciben igual. Cuando definimos el tama˜no m´aximo de
paquete a usar, ahora debe incluir esos 2 caracteres, por lo que deben leer
paquetes de datos desde el archivo de entrada que sean (tama˜no m´aximo de
paquete)-2.
Como siempre: Stop-and-Wait usa ventanas de tama˜no 1, Go-Back-N
usa una ventana de env´ıo de tama˜no N y una de recepci´on de tama˜no 1,
Selective-Repeat usa ambas ventanas de tama˜no N.
El tama˜no de la ventana (N) es un par´ametro que deben recibir (salvo
en el caso de Stop-and-Wait) y va entre 1 y 32767.
La idea es que la mayor´ıa de las p´erdidas de datos se producen cuando
el emisor va demasiado r´apido y no da tiempo a que el paquete de respuesta
llegue. Por eso, es importante en esta tarea permitir que los dos threads
ejecuten en paralelo y el receptor pueda ir recibiendo paquetes lo m´as r´apido
posibe, mientras el emisor debe detenerse si la ventana de env´ıo se le llena
con paquetes que no han sido recibidos a´un. Para eso, manejen los mutex de
forma que los bloques protegidos sean lo m´as peque˜nos posibles y aseg´urense
de soltarlos de vez en cuando para que el otro thread pueda entrar.
Usaremos entonces los argumentos: el tama˜no de paquete que se usar´a
y el tama˜no de la ventana (N) cuando no usemos Stop-and-Wait.
Para retransmitir, se les pide implementar un timeout adaptativo: parten
con un timeout de 0.5s, pero luego deben calcular el tiempo de ida y vuelta
de los paquetes (RTT), es decir el tiempo transcurrido entre el env´ıo de un
paquete y su recepci´on de vuelta. Deben ignorar los paquetes retransmitidos.
Cada vez que logren calcular un RTT, definan el timeout como RT T ∗ 3.
Como ahora es UDP, no tenemos un cierre de conexi´on, por lo que, al
terminar el env´ıo, deben enviar un paquete de tama˜no cero (es decir, los 2
n´umeros de secuencia correspondientes y nada m´as). Al recibir ese paquete,
saben que es el ´ultimo de la secuencia.
Si est´an en Stop-and-Wait o Go-Back-N, recibir el ´ultimo paquete les
permite terminar todo. Si est´an en selective-repeat, no es tan simple, por
que pueden haber paquetes pendientes de recepci´on aun. En ese caso, s´olo
pueden terminar cuando sacan el paquete vac´ıo de la ventana de recepci´on.
El cliente que deben escribir recibe el tama˜no de paquete a proponer,
la ventana, servidor y puerto. En la entrada est´andar el archivo a enviar
y en la salida est´andar el archivo que se recibe. Al terminar escriba en la
salida de errores el tama˜no de paquete y ventana y los errores corregidos:
2 Entregables 4
retransmisiones y paquetes recibidos fuera de orden.
./copy_client.py pack_sz win host port <filein >fileout
Hay un servidor de eco corriendo en anakena.dcc.uchile.cl puerto 1818
UDP. Pero, puedan correrlo localmente para pruebas con localhost tambi´en.
Un ejemplo de ejecuci´on ser´ıa:
% ./copy_client.py 8000 10000 anakena.dcc.uchile.cl 1818 </etc/services > OUT
Usando: pack: 8000, maxwin: 10000
Errores env´ıo: 2
Errores recepci´on: 2
Escriban ese mismo tipo de salida de errores en sus clientes, para que
podamos corregirlos f´acilmente.
Si su programa est´a bien escrito, el archivo de entrada y el de salida
deben quedar con contenido id´entico.
Para enviar/leer paquetes binarios del socket usen send() y recv() directamente, sin pasar por encode()/decode(). El arreglo de bytes que usan es
un bytearray en el concepto de Python.
Para generar n´umeros de secuencia binarios, usen las funciones primitivas
de python: int.to bytes() y int.from bytes()
Para el desarrollo del programa, les recomiendo ir en orden: implementar
primero un stop-and-wait, luego hacer un Go-Back-N y luego un SelectiveRepeat. De esa forma, van asegurando nota en la tarea si se demoran m´as
de lo esperado (estas tareas son m´as complicadas en la pr´actica de lo que
parecen en la teor´ıa).
De la misma forma, para cada protocolo, les recomiendo probar primero
en localhost hasta que todo funcione, y ah´ı pueden ir a probar a anakena,
donde todo ser´a m´as dif´ıcil.
2. Entregables
B´asicamente entregar el archivo con el cliente que implementa el protocolo.
En un archivo aparte responder las preguntas siguientes (digamos, unos
5.000 caracteres m´aximo por pregunta):
1. Genere algunos experimentos con diversos tama˜nos de paquete y ventanas (con anakena). Mida el tiempo total que toma la transferencia
y recomiende los mejores valores para su caso seg´un sus resultados.
2 Entregables 5
2. Compare sus resultados con lo logrado en la Tarea1. Comente las diferencias.
3. Si implement´o m´as de un protocolo, compare Stop-and-Wait, Go-BackN y Selective-Repeat. Pruebe en localhost y en anakena. ¿Son coherentes sus resultados con la teor´ıa?
4. En esta tarea pusimos que el timeout es 3 veces el ´ultimo RTT medido.
¿Podemos saber si ese valor es a veces demasiado peque˜no y gener´o
retransmisiones innecesarias?
5. De toda esta experiencia, ¿qu´e cree Ud que es m´as importante para ser
eficientes?: ¿tama˜no paquete, tama˜no ventana, protocolo, timeout?